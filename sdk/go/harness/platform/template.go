// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package platform

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-harness/sdk/go/harness/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Resource for creating a Template. Description field is deprecated
//
// ## Remote Pipeline template
//
//	resource "platform.Template" "pipelineTemplateRemote" {
//	  identifier = "identifier"
//	  orgId     = harness_platform_project.test.org_id
//	  projectId = harness_platform_project.test.id
//	  name       = "name"
//	  comments   = "comments"
//	  version    = "ab"
//	  isStable  = true
//	  gitDetails {
//	    branchName    = "main"
//	    commitMessage = "Commit"
//	    filePath      = "filePath"
//	    connectorRef  = "account.connector_ref"
//	    storeType     = "REMOTE"
//	    repoName      = "repoName"
//	  }
//	  templateYaml = <<-EOT
//
// template:
//
//	  name: "name"
//	  identifier: "identifier"
//	  versionLabel: "ab"
//	  type: Pipeline
//	  projectIdentifier: ${harness_platform_project.test.id}
//	  orgIdentifier: ${harness_platform_project.test.org_id}
//	  tags: {}
//	  spec:
//	    stages:
//	      - stage:
//	          identifier: dvvdvd
//	          name: dvvdvd
//	          description: ""
//	          type: Deployment
//	          spec:
//	            deploymentType: Kubernetes
//	            service:
//	              serviceRef: <+input>
//	              serviceInputs: <+input>
//	            environment:
//	              environmentRef: <+input>
//	              deployToAll: false
//	              environmentInputs: <+input>
//	              serviceOverrideInputs: <+input>
//	              infrastructureDefinitions: <+input>
//	            execution:
//	              steps:
//	                - step:
//	                    name: Rollout Deployment
//	                    identifier: rolloutDeployment
//	                    type: K8sRollingDeploy
//	                    timeout: 10m
//	                    spec:
//	                      skipDryRun: false
//	                      pruningEnabled: false
//	              rollbackSteps:
//	                - step:
//	                    name: Rollback Rollout Deployment
//	                    identifier: rollbackRolloutDeployment
//	                    type: K8sRollingRollback
//	                    timeout: 10m
//	                    spec:
//	                      pruningEnabled: false
//	          tags: {}
//	          failureStrategies:
//	            - onFailure:
//	                errors:
//	                  - AllErrors
//	                action:
//	                  type: StageRollback
//
//	  EOT
//	}
//
// ## Remote Pipeline template to create new branch from existing base branch
//
//	resource "platform.Template" "pipelineTemplateRemote" {
//	  identifier = "identifier"
//	  orgId     = harness_platform_project.test.org_id
//	  projectId = harness_platform_project.test.id
//	  name       = "name"
//	  comments   = "comments"
//	  version    = "ab"
//	  isStable  = true
//	  gitDetails {
//	    branchName    = "newBranch"
//	    commitMessage = "Commit"
//	    filePath      = "filePath"
//	    connectorRef  = "account.connector_ref"
//	    storeType     = "REMOTE"
//	    repoName      = "repoName"
//	    baseBranch    = "main"
//	  }
//	  templateYaml = <<-EOT
//
// template:
//
//	  name: "name"
//	  identifier: "identifier"
//	  versionLabel: "ab"
//	  type: Pipeline
//	  projectIdentifier: ${harness_platform_project.test.id}
//	  orgIdentifier: ${harness_platform_project.test.org_id}
//	  tags: {}
//	  spec:
//	    stages:
//	      - stage:
//	          identifier: dvvdvd
//	          name: dvvdvd
//	          description: ""
//	          type: Deployment
//	          spec:
//	            deploymentType: Kubernetes
//	            service:
//	              serviceRef: <+input>
//	              serviceInputs: <+input>
//	            environment:
//	              environmentRef: <+input>
//	              deployToAll: false
//	              environmentInputs: <+input>
//	              serviceOverrideInputs: <+input>
//	              infrastructureDefinitions: <+input>
//	            execution:
//	              steps:
//	                - step:
//	                    name: Rollout Deployment
//	                    identifier: rolloutDeployment
//	                    type: K8sRollingDeploy
//	                    timeout: 10m
//	                    spec:
//	                      skipDryRun: false
//	                      pruningEnabled: false
//	              rollbackSteps:
//	                - step:
//	                    name: Rollback Rollout Deployment
//	                    identifier: rollbackRolloutDeployment
//	                    type: K8sRollingRollback
//	                    timeout: 10m
//	                    spec:
//	                      pruningEnabled: false
//	          tags: {}
//	          failureStrategies:
//	            - onFailure:
//	                errors:
//	                  - AllErrors
//	                action:
//	                  type: StageRollback
//
//	  EOT
//	}
//
// ## Inline Pipeline template
//
//	resource "platform.Template" "pipelineTemplateInline" {
//	  identifier    = "identifier"
//	  orgId        = harness_platform_project.test.org_id
//	  projectId    = harness_platform_project.test.id
//	  name          = "name"
//	  comments      = "comments"
//	  version       = "ab"
//	  isStable     = true
//	  templateYaml = <<-EOT
//
// template:
//
//	  name: "name"
//	  identifier: "identifier"
//	  versionLabel: "ab"
//	  type: Pipeline
//	  projectIdentifier: ${harness_platform_project.test.id}
//	  orgIdentifier: ${harness_platform_project.test.org_id}
//	  tags: {}
//	  spec:
//	    stages:
//	      - stage:
//	          identifier: dvvdvd
//	          name: dvvdvd
//	          description: ""
//	          type: Deployment
//	          spec:
//	            deploymentType: Kubernetes
//	            service:
//	              serviceRef: <+input>
//	              serviceInputs: <+input>
//	            environment:
//	              environmentRef: <+input>
//	              deployToAll: false
//	              environmentInputs: <+input>
//	              serviceOverrideInputs: <+input>
//	              infrastructureDefinitions: <+input>
//	            execution:
//	              steps:
//	                - step:
//	                    name: Rollout Deployment
//	                    identifier: rolloutDeployment
//	                    type: K8sRollingDeploy
//	                    timeout: 10m
//	                    spec:
//	                      skipDryRun: false
//	                      pruningEnabled: false
//	              rollbackSteps:
//	                - step:
//	                    name: Rollback Rollout Deployment
//	                    identifier: rollbackRolloutDeployment
//	                    type: K8sRollingRollback
//	                    timeout: 10m
//	                    spec:
//	                      pruningEnabled: false
//	          tags: {}
//	          failureStrategies:
//	            - onFailure:
//	                errors:
//	                  - AllErrors
//	                action:
//	                  type: StageRollback
//
//	  EOT
//	}
//
// ## Inline Step template
//
//	resource "platform.Template" "stepTemplateInline" {
//	  identifier    = "identifier"
//	  orgId        = harness_platform_project.test.org_id
//	  projectId    = harness_platform_project.test.id
//	  name          = "name"
//	  comments      = "comments"
//	  version       = "ab"
//	  isStable     = true
//	  templateYaml = <<-EOT
//
// template:
//
//	  name: "name"
//	  identifier: "identifier"
//	  versionLabel: "ab"
//	  type: Step
//	  projectIdentifier: ${harness_platform_project.test.id}
//	  orgIdentifier: ${harness_platform_project.test.org_id}
//	  tags: {}
//	  spec:
//	    timeout: 10m
//	    type: ShellScript
//	    spec:
//	      shell: Bash
//	      onDelegate: true
//	      source:
//	        type: Inline
//	        spec:
//	          script: <+input>
//	      environmentVariables: []
//	      outputVariables: []
//
//	  EOT
//	}
//
// ## Remote Step template
//
//	resource "platform.Template" "stepTemplateRemote" {
//	  identifier = "identifier"
//	  orgId     = harness_platform_project.test.org_id
//	  projectId = harness_platform_project.test.id
//	  name       = "name"
//	  comments   = "comments"
//	  version    = "ab"
//	  isStable  = true
//	  gitDetails {
//	    branchName    = "main"
//	    commitMessage = "Commit"
//	    filePath      = "filePath"
//	    connectorRef  = "account.connector_ref"
//	    storeType     = "REMOTE"
//	    repoName      = "repoName"
//	  }
//	  templateYaml = <<-EOT
//
// template:
//
//	  name: "name"
//	  identifier: "identifier"
//	  versionLabel: "ab"
//	  type: Step
//	  projectIdentifier: ${harness_platform_project.test.id}
//	  orgIdentifier: ${harness_platform_project.test.org_id}
//	  tags: {}
//	  spec:
//	    timeout: 10m
//	    type: ShellScript
//	    spec:
//	      shell: Bash
//	      onDelegate: true
//	      source:
//	        type: Inline
//	        spec:
//	          script: <+input>
//	      environmentVariables: []
//	      outputVariables: []
//
//	  EOT
//	}
//
// ## Remote Step template to create new branch from existing branch
//
//	resource "platform.Template" "stepTemplateRemote" {
//	  identifier = "identifier"
//	  orgId     = harness_platform_project.test.org_id
//	  projectId = harness_platform_project.test.id
//	  name       = "name"
//	  comments   = "comments"
//	  version    = "ab"
//	  isStable  = true
//	  gitDetails {
//	    branchName    = "newBranch"
//	    commitMessage = "Commit"
//	    filePath      = "filePath"
//	    connectorRef  = "account.connector_ref"
//	    storeType     = "REMOTE"
//	    repoName      = "repoName"
//	    baseBranch    = "main"
//	  }
//	  templateYaml = <<-EOT
//
// template:
//
//	  name: "name"
//	  identifier: "identifier"
//	  versionLabel: "ab"
//	  type: Step
//	  projectIdentifier: ${harness_platform_project.test.id}
//	  orgIdentifier: ${harness_platform_project.test.org_id}
//	  tags: {}
//	  spec:
//	    timeout: 10m
//	    type: ShellScript
//	    spec:
//	      shell: Bash
//	      onDelegate: true
//	      source:
//	        type: Inline
//	        spec:
//	          script: <+input>
//	      environmentVariables: []
//	      outputVariables: []
//
//	  EOT
//	}
//
// ## Inline Stage template
//
//	resource "platform.Template" "stageTemplateInline" {
//	  identifier    = "identifier"
//	  orgId        = harness_platform_project.test.org_id
//	  projectId    = harness_platform_project.test.id
//	  name          = "name"
//	  comments      = "comments"
//	  version       = "ab"
//	  isStable     = true
//	  templateYaml = <<-EOT
//
// template:
//
//	  name: "name"
//	  identifier: "identifier"
//	  versionLabel: "ab"
//	  type: Stage
//	  projectIdentifier: ${harness_platform_project.test.id}
//	  orgIdentifier: ${harness_platform_project.test.org_id}
//	  tags: {}
//	  spec:
//	    type: Deployment
//	    spec:
//	      deploymentType: Kubernetes
//	      service:
//	        serviceRef: <+input>
//	        serviceInputs: <+input>
//	      environment:
//	        environmentRef: <+input>
//	        deployToAll: false
//	        environmentInputs: <+input>
//	        infrastructureDefinitions: <+input>
//	      execution:
//	        steps:
//	          - step:
//	              type: ShellScript
//	              name: Shell Script_1
//	              identifier: ShellScript_1
//	              spec:
//	                shell: Bash
//	                onDelegate: true
//	                source:
//	                  type: Inline
//	                  spec:
//	                    script: <+input>
//	                environmentVariables: []
//	                outputVariables: []
//	              timeout: <+input>
//	        rollbackSteps: []
//	    failureStrategies:
//	      - onFailure:
//	          errors:
//	            - AllErrors
//	          action:
//	            type: StageRollback
//
//	  EOT
//	}
//
// ## Remote Stage template
//
//	resource "platform.Template" "stageTemplateRemote" {
//	  identifier = "identifier"
//	  orgId     = harness_platform_project.test.org_id
//	  projectId = harness_platform_project.test.id
//	  name       = "name"
//	  comments   = "comments"
//	  version    = "ab"
//	  isStable  = true
//	  gitDetails {
//	    branchName    = "main"
//	    commitMessage = "Commit"
//	    filePath      = "filePath"
//	    connectorRef  = "account.connector_ref"
//	    storeType     = "REMOTE"
//	    repoName      = "repoName"
//	  }
//	  templateYaml = <<-EOT
//
// template:
//
//	  name: "name"
//	  identifier: "identifier"
//	  versionLabel: "ab"
//	  type: Stage
//	  projectIdentifier: ${harness_platform_project.test.id}
//	  orgIdentifier: ${harness_platform_project.test.org_id}
//	  tags: {}
//	  spec:
//	    type: Deployment
//	    spec:
//	      deploymentType: Kubernetes
//	      service:
//	        serviceRef: <+input>
//	        serviceInputs: <+input>
//	      environment:
//	        environmentRef: <+input>
//	        deployToAll: false
//	        environmentInputs: <+input>
//	        infrastructureDefinitions: <+input>
//	      execution:
//	        steps:
//	          - step:
//	              type: ShellScript
//	              name: Shell Script_1
//	              identifier: ShellScript_1
//	              spec:
//	                shell: Bash
//	                onDelegate: true
//	                source:
//	                  type: Inline
//	                  spec:
//	                    script: <+input>
//	                environmentVariables: []
//	                outputVariables: []
//	              timeout: <+input>
//	        rollbackSteps: []
//	    failureStrategies:
//	      - onFailure:
//	          errors:
//	            - AllErrors
//	          action:
//	            type: StageRollback
//
//	  EOT
//	}
//
// ## Remote Stage template to create new branch from existing branch
//
//	resource "platform.Template" "stageTemplateRemote" {
//	  identifier = "identifier"
//	  orgId     = harness_platform_project.test.org_id
//	  projectId = harness_platform_project.test.id
//	  name       = "name"
//	  comments   = "comments"
//	  version    = "ab"
//	  isStable  = true
//	  gitDetails {
//	    branchName    = "newBranch"
//	    commitMessage = "Commit"
//	    filePath      = "filePath"
//	    connectorRef  = "account.connector_ref"
//	    storeType     = "REMOTE"
//	    repoName      = "repoName"
//	    baseBranch    = "main"
//	  }
//	  templateYaml = <<-EOT
//
// template:
//
//	  name: "name"
//	  identifier: "identifier"
//	  versionLabel: "ab"
//	  type: Stage
//	  projectIdentifier: ${harness_platform_project.test.id}
//	  orgIdentifier: ${harness_platform_project.test.org_id}
//	  tags: {}
//	  spec:
//	    type: Deployment
//	    spec:
//	      deploymentType: Kubernetes
//	      service:
//	        serviceRef: <+input>
//	        serviceInputs: <+input>
//	      environment:
//	        environmentRef: <+input>
//	        deployToAll: false
//	        environmentInputs: <+input>
//	        infrastructureDefinitions: <+input>
//	      execution:
//	        steps:
//	          - step:
//	              type: ShellScript
//	              name: Shell Script_1
//	              identifier: ShellScript_1
//	              spec:
//	                shell: Bash
//	                onDelegate: true
//	                source:
//	                  type: Inline
//	                  spec:
//	                    script: <+input>
//	                environmentVariables: []
//	                outputVariables: []
//	              timeout: <+input>
//	        rollbackSteps: []
//	    failureStrategies:
//	      - onFailure:
//	          errors:
//	            - AllErrors
//	          action:
//	            type: StageRollback
//
//	  EOT
//	}
//
// ## Inline StepGroup template
//
//	resource "platform.Template" "stepgroupTemplateInline" {
//	  identifier    = "identifier"
//	  orgId        = harness_platform_project.test.org_id
//	  projectId    = harness_platform_project.test.id
//	  name          = "name"
//	  comments      = "comments"
//	  version       = "ab"
//	  isStable     = true
//	  templateYaml = <<-EOT
//
// template:
//
//	  name: "name"
//	  identifier: "identifier"
//	  versionLabel: "ab"
//	  type: StepGroup
//	  projectIdentifier: ${harness_platform_project.test.id}
//	  orgIdentifier: ${harness_platform_project.test.org_id}
//	  tags: {}
//	  spec:
//	    stageType: Deployment
//	    steps:
//	      - step:
//	          type: ShellScript
//	          name: Shell Script_1
//	          identifier: ShellScript_1
//	          spec:
//	            shell: Bash
//	            onDelegate: true
//	            source:
//	              type: Inline
//	              spec:
//	                script: <+input>
//	            environmentVariables: []
//	            outputVariables: []
//	          timeout: 10m
//
//	  EOT
//	}
//
// ## Remote StepGroup template
//
//	resource "platform.Template" "stepgroupTemplateRemote" {
//	  identifier = "identifier"
//	  orgId     = harness_platform_project.test.org_id
//	  projectId = harness_platform_project.test.id
//	  name       = "name"
//	  comments   = "comments"
//	  version    = "ab"
//	  isStable  = true
//	  gitDetails {
//	    branchName    = "main"
//	    commitMessage = "Commit"
//	    filePath      = "filePath"
//	    connectorRef  = "account.connector_ref"
//	    storeType     = "REMOTE"
//	    repoName      = "repoName"
//	  }
//	  templateYaml = <<-EOT
//
// template:
//
//	  name: "name"
//	  identifier: "identifier"
//	  versionLabel: "ab"
//	  type: StepGroup
//	  projectIdentifier: ${harness_platform_project.test.id}
//	  orgIdentifier: ${harness_platform_project.test.org_id}
//	  tags: {}
//	  spec:
//	    stageType: Deployment
//	    steps:
//	      - step:
//	          type: ShellScript
//	          name: Shell Script_1
//	          identifier: ShellScript_1
//	          spec:
//	            shell: Bash
//	            onDelegate: true
//	            source:
//	              type: Inline
//	              spec:
//	                script: <+input>
//	            environmentVariables: []
//	            outputVariables: []
//	          timeout: 10m
//
//	  EOT
//	}
//
// ## Remote StepGroup template to create new branch from existing branch
//
//	resource "platform.Template" "stepgroupTemplateRemote" {
//	  identifier = "identifier"
//	  orgId     = harness_platform_project.test.org_id
//	  projectId = harness_platform_project.test.id
//	  name       = "name"
//	  comments   = "comments"
//	  version    = "ab"
//	  isStable  = true
//	  gitDetails {
//	    branchName    = "newBranch"
//	    commitMessage = "Commit"
//	    filePath      = "filePath"
//	    connectorRef  = "account.connector_ref"
//	    storeType     = "REMOTE"
//	    repoName      = "repoName"
//	    baseBranch    = "main"
//	  }
//	  templateYaml = <<-EOT
//
// template:
//
//	  name: "name"
//	  identifier: "identifier"
//	  versionLabel: "ab"
//	  type: StepGroup
//	  projectIdentifier: ${harness_platform_project.test.id}
//	  orgIdentifier: ${harness_platform_project.test.org_id}
//	  tags: {}
//	  spec:
//	    stageType: Deployment
//	    steps:
//	      - step:
//	          type: ShellScript
//	          name: Shell Script_1
//	          identifier: ShellScript_1
//	          spec:
//	            shell: Bash
//	            onDelegate: true
//	            source:
//	              type: Inline
//	              spec:
//	                script: <+input>
//	            environmentVariables: []
//	            outputVariables: []
//	          timeout: 10m
//
//	  EOT
//	}
//
// ## Inline Monitered Service template
//
//	resource "platform.Template" "moniteredServiceTemplateInline" {
//	  identifier    = "identifier"
//	  orgId        = harness_platform_project.test.org_id
//	  projectId    = harness_platform_project.test.id
//	  name          = "name"
//	  comments      = "comments"
//	  version       = "ab"
//	  isStable     = true
//	  templateYaml = <<-EOT
//
// template:
//
//	  name: "name"
//	  identifier: "identifier"
//	  versionLabel: "ab"
//	  type: MonitoredService
//	  projectIdentifier: ${harness_platform_project.test.id}
//	  orgIdentifier: ${harness_platform_project.test.org_id}
//	  tags: {}
//	  spec:
//	    serviceRef: <+input>
//	    environmentRef: <+input>
//	    type: Application
//	    sources:
//	      changeSources:
//	        - name: Harness CD Next Gen
//	          identifier: harnessCdNextGen
//	          type: HarnessCDNextGen
//	          enabled: true
//	          category: Deployment
//	          spec: {}
//	      healthSources:
//	        - name: health
//	          identifier: health
//	          type: AppDynamics
//	          spec:
//	            applicationName: <+input>
//	            tierName: <+input>
//	            metricData:
//	              Errors: true
//	              Performance: true
//	            metricDefinitions: []
//	            feature: Application Monitoring
//	            connectorRef: <+input>
//	            metricPacks:
//	              - identifier: Errors
//	              - identifier: Performance
//
//	  EOT
//	}
//
// ## Artifact Source template
//
//	resource "platform.Template" "artifactSourceTemplate" {
//	  identifier    = "identifier"
//	  orgId        = harness_platform_project.test.org_id
//	  projectId    = harness_platform_project.test.id
//	  name          = "name"
//	  comments      = "comments"
//	  version       = "ab"
//	  isStable     = true
//	  templateYaml = <<-EOT
//
// template:
//
//	  name: "name"
//	  identifier: "identifier"
//	  versionLabel: "ab"
//	  type: ArtifactSource
//	  projectIdentifier: ${harness_platform_project.test.id}
//	  orgIdentifier: ${harness_platform_project.test.org_id}
//	  tags: {}
//	  spec:
//	    type: DockerRegistry
//	    spec:
//	      imagePath: library/nginx
//	      tag: <+input>
//	      connectorRef: account.Harness_DockerHub
//
//	  EOT
//	}
//
// ## Deployment template
//
//	resource "platform.Template" "deploymentTemplate" {
//	  identifier    = "identifier"
//	  orgId        = harness_platform_project.test.org_id
//	  projectId    = harness_platform_project.test.id
//	  name          = "name"
//	  comments      = "comments"
//	  version       = "ab"
//	  isStable     = true
//	  templateYaml = <<-EOT
//
// template:
//
//	  name: "name"
//	  identifier: "identifier"
//	  versionLabel: "ab"
//	  type: CustomDeployment
//	  projectIdentifier: ${harness_platform_project.test.id}
//	  orgIdentifier: ${harness_platform_project.test.org_id}
//	  tags: {}
//	  spec:
//	    infrastructure:
//	      variables:
//	        - name: kubeConnector
//	          type: Connector
//	          value: <+input>
//	          description: ""
//	      fetchInstancesScript:
//	        store:
//	          type: Inline
//	          spec:
//	            content: |
//	              #
//	              # Script is expected to query Infrastructure and dump json
//	              # in $INSTANCE_OUTPUT_PATH file path
//	              #
//	              # Harness is expected to initialize ${INSTANCE_OUTPUT_PATH}
//	              # environment variable - a random unique file path on delegate,
//	              # so script execution can save the result.
//	              #
//	              /opt/harness-delegate/client-tools/kubectl/v1.19.2/kubectl get pods --namespace=harness-delegate-ng -o json > $INSTANCE_OUTPUT_PATH
//	      instanceAttributes:
//	        - name: instancename
//	          jsonPath: metadata.name
//	          description: ""
//	      instancesListPath: items
//	    execution:
//	      stepTemplateRefs: []
//
//	  EOT
//	}
//
// ## Secrets Manager template
//
//	resource "platform.Template" "secretsManagerTemplate" {
//	  identifier    = "identifier"
//	  orgId        = harness_platform_project.test.org_id
//	  projectId    = harness_platform_project.test.id
//	  name          = "name"
//	  comments      = "comments"
//	  version       = "ab"
//	  isStable     = true
//	  templateYaml = <<-EOT
//
// template:
//
//	  name: "name"
//	  identifier: "identifier"
//	  versionLabel: "ab"
//	  type: SecretManager
//	  projectIdentifier: ${harness_platform_project.test.id}
//	  orgIdentifier: ${harness_platform_project.test.org_id}
//	  tags: {}
//	  spec:
//	    executionTarget: {}
//	    shell: Bash
//	    onDelegate: true
//	    source:
//	      spec:
//	        script: |-
//	          curl -o secret.json -X GET https://example.com/<+secretManager.environmentVariables.enginename>/<+secretManager.environmentVariables.path> -H 'X-Vault-Token: <+secrets.getValue("vaultTokenOne")>'
//	          secret=$(jq -r '.data."<+secretManager.environmentVariables.key>"' secret.json)
//	        type: Inline
//	    environmentVariables:
//	      - name: enginename
//	        type: String
//	        value: <+input>
//	      - name: path
//	        type: String
//	        value: <+input>
//	      - name: key
//	        type: String
//	        value: <+input>
//
//	  EOT
//	}
//
// # Import org level template
//
// ```sh
// $ pulumi import harness:platform/template:Template example <ord_id>/<template_id>
// ```
//
// # Import project level template
//
// ```sh
// $ pulumi import harness:platform/template:Template example <org_id>/<project_id>/<template_id>
// ```
type Template struct {
	pulumi.CustomResourceState

	// Specify comment with respect to changes.
	Comments pulumi.StringPtrOutput `pulumi:"comments"`
	// Description of the entity. Description field is deprecated
	//
	// Deprecated: description field is deprecated
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Enable this flag for force deletion of template
	ForceDelete pulumi.StringOutput `pulumi:"forceDelete"`
	// Contains parameters related to creating an Entity for Git Experience.
	GitDetails TemplateGitDetailsOutput `pulumi:"gitDetails"`
	// Unique identifier of the resource
	Identifier pulumi.StringOutput `pulumi:"identifier"`
	// True if given version for template to be set as stable.
	IsStable pulumi.BoolPtrOutput `pulumi:"isStable"`
	// Name of the Variable
	Name pulumi.StringOutput `pulumi:"name"`
	// Organization Identifier for the Entity
	OrgId pulumi.StringPtrOutput `pulumi:"orgId"`
	// Project Identifier for the Entity
	ProjectId pulumi.StringPtrOutput `pulumi:"projectId"`
	// Tags to associate with the resource.
	Tags pulumi.StringArrayOutput `pulumi:"tags"`
	// Yaml for creating new Template. In YAML, to reference an entity at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference an entity at the account scope, prefix 'account` to the expression: account.{identifier}. For eg, to reference a connector with identifier 'connectorId' at the organization scope in a stage mention it as connectorRef: org.connectorId.
	TemplateYaml pulumi.StringOutput `pulumi:"templateYaml"`
	// Version Label for Template.
	Version pulumi.StringOutput `pulumi:"version"`
}

// NewTemplate registers a new resource with the given unique name, arguments, and options.
func NewTemplate(ctx *pulumi.Context,
	name string, args *TemplateArgs, opts ...pulumi.ResourceOption) (*Template, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Identifier == nil {
		return nil, errors.New("invalid value for required argument 'Identifier'")
	}
	if args.TemplateYaml == nil {
		return nil, errors.New("invalid value for required argument 'TemplateYaml'")
	}
	if args.Version == nil {
		return nil, errors.New("invalid value for required argument 'Version'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Template
	err := ctx.RegisterResource("harness:platform/template:Template", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetTemplate gets an existing Template resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetTemplate(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *TemplateState, opts ...pulumi.ResourceOption) (*Template, error) {
	var resource Template
	err := ctx.ReadResource("harness:platform/template:Template", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Template resources.
type templateState struct {
	// Specify comment with respect to changes.
	Comments *string `pulumi:"comments"`
	// Description of the entity. Description field is deprecated
	//
	// Deprecated: description field is deprecated
	Description *string `pulumi:"description"`
	// Enable this flag for force deletion of template
	ForceDelete *string `pulumi:"forceDelete"`
	// Contains parameters related to creating an Entity for Git Experience.
	GitDetails *TemplateGitDetails `pulumi:"gitDetails"`
	// Unique identifier of the resource
	Identifier *string `pulumi:"identifier"`
	// True if given version for template to be set as stable.
	IsStable *bool `pulumi:"isStable"`
	// Name of the Variable
	Name *string `pulumi:"name"`
	// Organization Identifier for the Entity
	OrgId *string `pulumi:"orgId"`
	// Project Identifier for the Entity
	ProjectId *string `pulumi:"projectId"`
	// Tags to associate with the resource.
	Tags []string `pulumi:"tags"`
	// Yaml for creating new Template. In YAML, to reference an entity at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference an entity at the account scope, prefix 'account` to the expression: account.{identifier}. For eg, to reference a connector with identifier 'connectorId' at the organization scope in a stage mention it as connectorRef: org.connectorId.
	TemplateYaml *string `pulumi:"templateYaml"`
	// Version Label for Template.
	Version *string `pulumi:"version"`
}

type TemplateState struct {
	// Specify comment with respect to changes.
	Comments pulumi.StringPtrInput
	// Description of the entity. Description field is deprecated
	//
	// Deprecated: description field is deprecated
	Description pulumi.StringPtrInput
	// Enable this flag for force deletion of template
	ForceDelete pulumi.StringPtrInput
	// Contains parameters related to creating an Entity for Git Experience.
	GitDetails TemplateGitDetailsPtrInput
	// Unique identifier of the resource
	Identifier pulumi.StringPtrInput
	// True if given version for template to be set as stable.
	IsStable pulumi.BoolPtrInput
	// Name of the Variable
	Name pulumi.StringPtrInput
	// Organization Identifier for the Entity
	OrgId pulumi.StringPtrInput
	// Project Identifier for the Entity
	ProjectId pulumi.StringPtrInput
	// Tags to associate with the resource.
	Tags pulumi.StringArrayInput
	// Yaml for creating new Template. In YAML, to reference an entity at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference an entity at the account scope, prefix 'account` to the expression: account.{identifier}. For eg, to reference a connector with identifier 'connectorId' at the organization scope in a stage mention it as connectorRef: org.connectorId.
	TemplateYaml pulumi.StringPtrInput
	// Version Label for Template.
	Version pulumi.StringPtrInput
}

func (TemplateState) ElementType() reflect.Type {
	return reflect.TypeOf((*templateState)(nil)).Elem()
}

type templateArgs struct {
	// Specify comment with respect to changes.
	Comments *string `pulumi:"comments"`
	// Description of the entity. Description field is deprecated
	//
	// Deprecated: description field is deprecated
	Description *string `pulumi:"description"`
	// Enable this flag for force deletion of template
	ForceDelete *string `pulumi:"forceDelete"`
	// Contains parameters related to creating an Entity for Git Experience.
	GitDetails *TemplateGitDetails `pulumi:"gitDetails"`
	// Unique identifier of the resource
	Identifier string `pulumi:"identifier"`
	// True if given version for template to be set as stable.
	IsStable *bool `pulumi:"isStable"`
	// Name of the Variable
	Name *string `pulumi:"name"`
	// Organization Identifier for the Entity
	OrgId *string `pulumi:"orgId"`
	// Project Identifier for the Entity
	ProjectId *string `pulumi:"projectId"`
	// Tags to associate with the resource.
	Tags []string `pulumi:"tags"`
	// Yaml for creating new Template. In YAML, to reference an entity at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference an entity at the account scope, prefix 'account` to the expression: account.{identifier}. For eg, to reference a connector with identifier 'connectorId' at the organization scope in a stage mention it as connectorRef: org.connectorId.
	TemplateYaml string `pulumi:"templateYaml"`
	// Version Label for Template.
	Version string `pulumi:"version"`
}

// The set of arguments for constructing a Template resource.
type TemplateArgs struct {
	// Specify comment with respect to changes.
	Comments pulumi.StringPtrInput
	// Description of the entity. Description field is deprecated
	//
	// Deprecated: description field is deprecated
	Description pulumi.StringPtrInput
	// Enable this flag for force deletion of template
	ForceDelete pulumi.StringPtrInput
	// Contains parameters related to creating an Entity for Git Experience.
	GitDetails TemplateGitDetailsPtrInput
	// Unique identifier of the resource
	Identifier pulumi.StringInput
	// True if given version for template to be set as stable.
	IsStable pulumi.BoolPtrInput
	// Name of the Variable
	Name pulumi.StringPtrInput
	// Organization Identifier for the Entity
	OrgId pulumi.StringPtrInput
	// Project Identifier for the Entity
	ProjectId pulumi.StringPtrInput
	// Tags to associate with the resource.
	Tags pulumi.StringArrayInput
	// Yaml for creating new Template. In YAML, to reference an entity at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference an entity at the account scope, prefix 'account` to the expression: account.{identifier}. For eg, to reference a connector with identifier 'connectorId' at the organization scope in a stage mention it as connectorRef: org.connectorId.
	TemplateYaml pulumi.StringInput
	// Version Label for Template.
	Version pulumi.StringInput
}

func (TemplateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*templateArgs)(nil)).Elem()
}

type TemplateInput interface {
	pulumi.Input

	ToTemplateOutput() TemplateOutput
	ToTemplateOutputWithContext(ctx context.Context) TemplateOutput
}

func (*Template) ElementType() reflect.Type {
	return reflect.TypeOf((**Template)(nil)).Elem()
}

func (i *Template) ToTemplateOutput() TemplateOutput {
	return i.ToTemplateOutputWithContext(context.Background())
}

func (i *Template) ToTemplateOutputWithContext(ctx context.Context) TemplateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TemplateOutput)
}

// TemplateArrayInput is an input type that accepts TemplateArray and TemplateArrayOutput values.
// You can construct a concrete instance of `TemplateArrayInput` via:
//
//	TemplateArray{ TemplateArgs{...} }
type TemplateArrayInput interface {
	pulumi.Input

	ToTemplateArrayOutput() TemplateArrayOutput
	ToTemplateArrayOutputWithContext(context.Context) TemplateArrayOutput
}

type TemplateArray []TemplateInput

func (TemplateArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Template)(nil)).Elem()
}

func (i TemplateArray) ToTemplateArrayOutput() TemplateArrayOutput {
	return i.ToTemplateArrayOutputWithContext(context.Background())
}

func (i TemplateArray) ToTemplateArrayOutputWithContext(ctx context.Context) TemplateArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TemplateArrayOutput)
}

// TemplateMapInput is an input type that accepts TemplateMap and TemplateMapOutput values.
// You can construct a concrete instance of `TemplateMapInput` via:
//
//	TemplateMap{ "key": TemplateArgs{...} }
type TemplateMapInput interface {
	pulumi.Input

	ToTemplateMapOutput() TemplateMapOutput
	ToTemplateMapOutputWithContext(context.Context) TemplateMapOutput
}

type TemplateMap map[string]TemplateInput

func (TemplateMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Template)(nil)).Elem()
}

func (i TemplateMap) ToTemplateMapOutput() TemplateMapOutput {
	return i.ToTemplateMapOutputWithContext(context.Background())
}

func (i TemplateMap) ToTemplateMapOutputWithContext(ctx context.Context) TemplateMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TemplateMapOutput)
}

type TemplateOutput struct{ *pulumi.OutputState }

func (TemplateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Template)(nil)).Elem()
}

func (o TemplateOutput) ToTemplateOutput() TemplateOutput {
	return o
}

func (o TemplateOutput) ToTemplateOutputWithContext(ctx context.Context) TemplateOutput {
	return o
}

// Specify comment with respect to changes.
func (o TemplateOutput) Comments() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Template) pulumi.StringPtrOutput { return v.Comments }).(pulumi.StringPtrOutput)
}

// Description of the entity. Description field is deprecated
//
// Deprecated: description field is deprecated
func (o TemplateOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Template) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Enable this flag for force deletion of template
func (o TemplateOutput) ForceDelete() pulumi.StringOutput {
	return o.ApplyT(func(v *Template) pulumi.StringOutput { return v.ForceDelete }).(pulumi.StringOutput)
}

// Contains parameters related to creating an Entity for Git Experience.
func (o TemplateOutput) GitDetails() TemplateGitDetailsOutput {
	return o.ApplyT(func(v *Template) TemplateGitDetailsOutput { return v.GitDetails }).(TemplateGitDetailsOutput)
}

// Unique identifier of the resource
func (o TemplateOutput) Identifier() pulumi.StringOutput {
	return o.ApplyT(func(v *Template) pulumi.StringOutput { return v.Identifier }).(pulumi.StringOutput)
}

// True if given version for template to be set as stable.
func (o TemplateOutput) IsStable() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Template) pulumi.BoolPtrOutput { return v.IsStable }).(pulumi.BoolPtrOutput)
}

// Name of the Variable
func (o TemplateOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Template) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Organization Identifier for the Entity
func (o TemplateOutput) OrgId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Template) pulumi.StringPtrOutput { return v.OrgId }).(pulumi.StringPtrOutput)
}

// Project Identifier for the Entity
func (o TemplateOutput) ProjectId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Template) pulumi.StringPtrOutput { return v.ProjectId }).(pulumi.StringPtrOutput)
}

// Tags to associate with the resource.
func (o TemplateOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Template) pulumi.StringArrayOutput { return v.Tags }).(pulumi.StringArrayOutput)
}

// Yaml for creating new Template. In YAML, to reference an entity at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference an entity at the account scope, prefix 'account` to the expression: account.{identifier}. For eg, to reference a connector with identifier 'connectorId' at the organization scope in a stage mention it as connectorRef: org.connectorId.
func (o TemplateOutput) TemplateYaml() pulumi.StringOutput {
	return o.ApplyT(func(v *Template) pulumi.StringOutput { return v.TemplateYaml }).(pulumi.StringOutput)
}

// Version Label for Template.
func (o TemplateOutput) Version() pulumi.StringOutput {
	return o.ApplyT(func(v *Template) pulumi.StringOutput { return v.Version }).(pulumi.StringOutput)
}

type TemplateArrayOutput struct{ *pulumi.OutputState }

func (TemplateArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Template)(nil)).Elem()
}

func (o TemplateArrayOutput) ToTemplateArrayOutput() TemplateArrayOutput {
	return o
}

func (o TemplateArrayOutput) ToTemplateArrayOutputWithContext(ctx context.Context) TemplateArrayOutput {
	return o
}

func (o TemplateArrayOutput) Index(i pulumi.IntInput) TemplateOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Template {
		return vs[0].([]*Template)[vs[1].(int)]
	}).(TemplateOutput)
}

type TemplateMapOutput struct{ *pulumi.OutputState }

func (TemplateMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Template)(nil)).Elem()
}

func (o TemplateMapOutput) ToTemplateMapOutput() TemplateMapOutput {
	return o
}

func (o TemplateMapOutput) ToTemplateMapOutputWithContext(ctx context.Context) TemplateMapOutput {
	return o
}

func (o TemplateMapOutput) MapIndex(k pulumi.StringInput) TemplateOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Template {
		return vs[0].(map[string]*Template)[vs[1].(string)]
	}).(TemplateOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*TemplateInput)(nil)).Elem(), &Template{})
	pulumi.RegisterInputType(reflect.TypeOf((*TemplateArrayInput)(nil)).Elem(), TemplateArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TemplateMapInput)(nil)).Elem(), TemplateMap{})
	pulumi.RegisterOutputType(TemplateOutput{})
	pulumi.RegisterOutputType(TemplateArrayOutput{})
	pulumi.RegisterOutputType(TemplateMapOutput{})
}
